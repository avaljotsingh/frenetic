open Core
module Netkat = Frenetic.Netkat
module Fdd = Netkat.Fdd.FDD
module Automaton = Netkat.Global_compiler.Automaton

(*===========================================================================*)
(* UTILITY FUNCTIONS                                                         *)
(*===========================================================================*)

let parse_topo (policyfile : string) = Netkat.Json.pol_of_topo_file policyfile
let parse_tables (policyfile :string) = Netkat.Json.pol_of_tables_file policyfile

let parse_pred file = Netkat.Parser.pred_of_file file

let fmt = Format.formatter_of_out_channel stdout
let _ = Format.pp_set_margin fmt 120

let print_fdd fdd =
  printf "%s\n" (Netkat.Local_compiler.to_string fdd)

let dump data ~file =
  Out_channel.write_all file ~data

let dump_rules paths ~file =
  dump ~file (Netkat.Json.paths_to_json_string paths)

let dump_matches matches ~file =
  dump ~file (Netkat.Json.matches_to_json_string matches)

open Frenetic.Async
module Controller = NetKAT_Controller.Make(OpenFlow0x01_Plugin)

let print_table fdd sw =
  Netkat.Local_compiler.to_table sw fdd
  |> Frenetic.OpenFlow.string_of_flowTable ~label:(sprintf "Switch %Ld" sw)
  |> printf "%s\n"

let time f =
  let t1 = Unix.gettimeofday () in
  let r = f () in
  let t2 = Unix.gettimeofday () in
  (t2 -. t1, r)

let print_time ?(prefix="") time =
  printf "%scompilation time: %.4f\n" prefix time


let mk_prog edge pol topo = Netkat.Syntax.(
    Seq(Seq(Seq(edge,pol),
            Star(Seq(topo, pol))
          ),
        edge))

(*===========================================================================*)
(* FLAGS                                                                     *)
(*===========================================================================*)

module Flag = struct
  open Command.Spec

  let render_auto =
    flag "--render-auto" no_arg
      ~doc:" renders the intermediate representation \
            generated by the global compiler (symbolic NetKAT automaton).\
            Requires that graphviz is installed and on the PATH."

  let stdout =
    flag "--stdout" no_arg
      ~doc:"Print Edge-ified rules in json format to standard out instead of to edge.json"
end


(*===========================================================================*)
(* COMMANDS *)
(*===========================================================================*)

module Edge = struct
  let spec = Command.Spec.(
    empty
    +> anon ("topo" %: file)
    +> anon ("program" %: file)
    +> Flag.render_auto
  )

  let run topofile tablesfile render_auto () =
    let open Netkat.Global_compiler in
    let (edge, topo) = parse_topo topofile in
    let pol = parse_tables tablesfile in
    let program =  mk_prog edge pol topo in
    Printf.printf "%s\n\n" (Netkat.Pretty.string_of_policy program);
    let (t, rules) = time (fun () ->
                         Automaton.get_all_paths program ~render_auto ) in
    dump_rules rules ~file:("edge.json");
    print_time t;

end


module Hybrid = struct
  let spec = Command.Spec.(
      empty
      +> anon ("topo" %: file)
      +> anon ("network_tables" %: file)
      +> anon ("intent_tables" %: file)
      +> Flag.render_auto
  )

  let run topofile networkfile intentfile render_auto () =
    let open Netkat.Global_compiler in
    let (edge, topo) = parse_topo topofile in
    
    let netpol  = parse_tables networkfile in
    let network = mk_prog edge netpol topo in

    let intpol = parse_tables intentfile in
    let intent = mk_prog edge intpol topo in

    let (t, matches) = time (fun() -> Automaton.path_match network intent ~render_auto) in
    dump_matches matches  ~file:("hybrid.json");
    print_time t;
end



(*===========================================================================*)
(* BASIC SPECIFICATION OF COMMANDS                                           *)
(*===========================================================================*)

let source_route : Command.t = 
  Command.basic_spec
    ~summary:"Accepts topology file and table values, and compiles them to a source-routing scheme"
    (* ~readme: *)
    Edge.spec
    Edge.run

let hybrid : Command.t =
  Command.basic_spec
    ~summary:"Accepts real and intended topo file and table values; Compiles rules specifying the interface therebetween"
    Hybrid.spec
    Hybrid.run
  
let main : Command.t =
  Command.group
    ~summary:"Runs edge-based compiler schemes: source_route or hybrid"
    (* ~readme: *)
    [("source-route", source_route); ("hybrid", hybrid)]

